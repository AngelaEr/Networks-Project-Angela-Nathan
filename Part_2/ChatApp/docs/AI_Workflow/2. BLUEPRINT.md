# Blueprint: Chat Application for Computer Networks
# תוכנית עבודה: אפליקציית צ'אט לרשתות מחשבים

**Version:** 1.0
**Created:** 2025-01-11
**Status:** Awaiting Approval

---

## The User Story

**Need:** Students need a hands-on way to understand TCP/IP, HTTP, and WebSocket protocols by building and analyzing a real networked application.

**Value:** By implementing protocols from scratch (no frameworks), we gain deep understanding of:
- How browsers and servers communicate
- What happens at the byte level in network traffic
- How to read and interpret Wireshark captures

**Success Criteria:**
- [ ] Server accepts connections on port 8080
- [ ] Browser can load the chat UI via HTTP
- [ ] WebSocket connection established successfully
- [ ] Messages broadcast to all connected clients
- [ ] 5+ simultaneous clients work correctly
- [ ] Wireshark shows readable TCP/HTTP/WebSocket traffic

---

## The Logic

### Connection Flow
```
1. User opens browser → http://SERVER_IP:8080
2. Server receives HTTP GET request
3. Server responds with index.html
4. Browser requests style.css and script.js
5. Browser's JavaScript opens WebSocket connection
6. Server detects "Upgrade: websocket" header
7. Server performs WebSocket handshake (HTTP 101)
8. Bidirectional WebSocket channel established
9. User sends message → Server broadcasts to all
10. User closes tab → Server notifies others
```

### Message Flow
```
User types: "Hello!"
        ↓
Client JS adds metadata: "Nathan|Hello!|2025-01-11 14:30:00"
        ↓
    Server receives & unmasks
        ↓
    Server broadcasts to ALL clients
        ↓
All clients display: [14:30:00] Nathan: Hello!
```

**Note:** User only types the message text. The client application (JavaScript) automatically prepends the username and appends the timestamp before sending to the server.

### State Management
```
Server maintains (thread-safe with Lock):
┌─────────────────────────────────────┐
│  connected_clients = {              │
│    socket1: {"username": "Nathan"}, │
│    socket2: {"username": "Angela"}, │
│    ...                              │
│  }                                  │
└─────────────────────────────────────┘
```

---

## The Study

### Sources Referenced

| Source | Location | Key Learnings |
|--------|----------|---------------|
| Python Socket HOWTO | `Library/Sources/Python/networking/python_socket_howto.md` | send/recv patterns, message delimiting |
| Python Socket Library | `Library/Sources/Python/networking/python_socket_library.md` | AF_INET, SOCK_STREAM, bind/listen/accept |
| Python Threading | `Library/Sources/Python/concurrency/python_threading_library.md` | Thread class, Lock for synchronization |
| MDN WebSocket Servers | `Library/Sources/networking/websocket/writing_websocket_servers_mdn.md` | Handshake, framing, masking |
| MDN WebSocket API | `Library/Sources/networking/websocket/websocket_api_mdn.md` | JS client API |
| RFC 6455 | `Library/Sources/standards/websocket/rfc6455_websocket_protocol.md` | Official protocol spec |

### Key Technical Concepts

#### 1. TCP Socket Server Setup
```python
import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.bind(('0.0.0.0', 8080))
server.listen(5)

while True:
    client_socket, address = server.accept()
    # Handle in new thread
```

#### 2. HTTP Request Parsing
```
GET /index.html HTTP/1.1\r\n
Host: 192.168.1.10:8080\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n
Sec-WebSocket-Version: 13\r\n
\r\n
```
- First line: `METHOD PATH VERSION`
- Headers: `Key: Value` pairs
- Empty line signals end of headers

#### 3. WebSocket Handshake (RFC 6455)

**Client sends:** `Sec-WebSocket-Key` header

**Server computes Accept key:**
```python
import hashlib
import base64

GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
accept_key = base64.b64encode(
    hashlib.sha1((client_key + GUID).encode()).digest()
).decode()
```

**Server responds:**
```
HTTP/1.1 101 Switching Protocols\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
Sec-WebSocket-Accept: {accept_key}\r\n
\r\n
```

#### 4. WebSocket Frame Structure
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+-------------------------------+
```

**Opcodes:**
- `0x0` = Continuation
- `0x1` = Text frame
- `0x2` = Binary frame
- `0x8` = Close
- `0x9` = Ping
- `0xA` = Pong

#### 5. Unmasking Client Data
```python
def unmask(payload, mask_key):
    return bytes([payload[i] ^ mask_key[i % 4] for i in range(len(payload))])
```
- Client→Server: ALWAYS masked
- Server→Client: NEVER masked

#### 6. Thread-Safe Client Management
```python
import threading

clients_lock = threading.Lock()
connected_clients = {}

def add_client(sock, username):
    with clients_lock:
        connected_clients[sock] = {"username": username}

def broadcast(message):
    with clients_lock:
        for sock in connected_clients:
            send_websocket_frame(sock, message)
```

---

## The Tech

### Architecture
```
┌────────────────────────────────────────────────────────────┐
│                     SERVER (Python)                         │
│                       Port 8080                             │
├────────────────────────────────────────────────────────────┤
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │
│  │    Main      │    │    HTTP      │    │  WebSocket   │  │
│  │   Listener   │───▶│   Handler    │    │   Handler    │  │
│  │   (accept)   │    │  (static)    │    │  (realtime)  │  │
│  └──────────────┘    └──────────────┘    └──────────────┘  │
│         │                    │                   │          │
│         │                    └───────┬───────────┘          │
│         ▼                            ▼                      │
│  ┌──────────────┐         ┌──────────────────┐              │
│  │   Thread     │         │  Client Manager  │              │
│  │   per Client │         │  (thread-safe)   │              │
│  └──────────────┘         └──────────────────┘              │
└────────────────────────────────────────────────────────────┘
                              │
                    TCP/IP Network (Wireshark)
                              │
┌────────────────────────────────────────────────────────────┐
│                    CLIENTS (Browser)                        │
│               WebSocket API (native JS)                     │
│         const ws = new WebSocket("ws://IP:8080")           │
└────────────────────────────────────────────────────────────┘
```

### File Structure
```
ChatApp/
├── server/
│   ├── server.py              # Main entry point & socket listener
│   ├── http_handler.py        # HTTP request parsing & response
│   ├── websocket_handler.py   # WebSocket handshake & framing
│   └── client_manager.py      # Thread-safe client tracking
│
├── client/
│   ├── index.html             # Chat UI
│   ├── style.css              # Styling
│   └── script.js              # WebSocket client logic
│
├── docs/
│   ├── README.md              # סקירה כללית (Hebrew)
│   ├── SETUP.md               # הוראות התקנה (Hebrew)
│   └── WIRESHARK.md           # מדריך Wireshark (Hebrew)
│
└── run.py                     # Simple launcher script
```

### Technology Stack
| Component | Technology | Reason |
|-----------|------------|--------|
| Server | Python 3.8+ | Cross-platform, clear syntax |
| Networking | `socket` module | Pure TCP/IP, no abstraction |
| Concurrency | `threading` module | One thread per client, simple |
| Crypto | `hashlib`, `base64` | WebSocket handshake (SHA1) |
| Client | HTML/CSS/JS | Runs in any modern browser |
| WebSocket | Native `WebSocket` API | Built into all browsers |

---

## Checkpoints Checklist

### Phase 1: Project Setup & Basic TCP
> Goal: Server accepts TCP connections and reads data

- [ ] **CP1.1** Create folder structure (`ChatApp/server/`, `ChatApp/client/`, `ChatApp/docs/`)
- [ ] **CP1.2** Create `server.py` with socket listener on port 8080
- [ ] **CP1.3** Accept connections and print client address
- [ ] **CP1.4** Read raw data from client and print it
- [ ] **CP1.5** **TEST:** `curl http://localhost:8080` shows request in server console

---

### Phase 2: HTTP Handler
> Goal: Serve static files to browser

- [ ] **CP2.1** Create `http_handler.py` module
- [ ] **CP2.2** Parse HTTP request line (`GET /path HTTP/1.1`)
- [ ] **CP2.3** Parse HTTP headers into dictionary
- [ ] **CP2.4** Create basic `index.html` with "Hello World"
- [ ] **CP2.5** Serve `index.html` with `Content-Type: text/html`
- [ ] **CP2.6** Create `style.css` and serve with `Content-Type: text/css`
- [ ] **CP2.7** Create `script.js` and serve with `Content-Type: application/javascript`
- [ ] **CP2.8** Handle 404 for unknown paths
- [ ] **CP2.9** **TEST:** Browser loads page with styles at `http://localhost:8080`

---

### Phase 3: WebSocket Handshake
> Goal: Establish WebSocket connection

- [ ] **CP3.1** Create `websocket_handler.py` module
- [ ] **CP3.2** Detect `Upgrade: websocket` header in request
- [ ] **CP3.3** Extract `Sec-WebSocket-Key` from headers
- [ ] **CP3.4** Compute `Sec-WebSocket-Accept` (SHA1 + base64)
- [ ] **CP3.5** Send HTTP 101 Switching Protocols response
- [ ] **CP3.6** Add WebSocket connection button to `index.html`
- [ ] **CP3.7** Implement `new WebSocket()` in `script.js`
- [ ] **CP3.8** **TEST:** `ws.onopen` fires, console shows "Connected"

---

### Phase 4: WebSocket Framing
> Goal: Send and receive WebSocket messages

- [ ] **CP4.1** Implement frame parser (read FIN, opcode, mask, length)
- [ ] **CP4.2** Handle extended payload lengths (126 = 2 bytes, 127 = 8 bytes)
- [ ] **CP4.3** Extract 4-byte masking key
- [ ] **CP4.4** Unmask payload data (XOR with mask key)
- [ ] **CP4.5** Implement frame builder for server→client (unmasked)
- [ ] **CP4.6** Handle text frames (opcode 0x1)
- [ ] **CP4.7** Handle close frames (opcode 0x8)
- [ ] **CP4.8** Add message input to HTML
- [ ] **CP4.9** Send message from JS client
- [ ] **CP4.10** **TEST:** Send "Hello", receive echo back

---

### Phase 5: Multi-Client & Broadcast
> Goal: Multiple clients, messages visible to all

- [ ] **CP5.1** Create `client_manager.py` module
- [ ] **CP5.2** Implement thread-safe `connected_clients` dict with Lock
- [ ] **CP5.3** Implement `add_client(socket, username)`
- [ ] **CP5.4** Implement `remove_client(socket)`
- [ ] **CP5.5** Implement `broadcast(message)` to all clients
- [ ] **CP5.6** Create new thread for each WebSocket client
- [ ] **CP5.7** Parse username from first message (join protocol)
- [ ] **CP5.8** Broadcast "X joined the chat" on connect
- [ ] **CP5.9** Broadcast "X left the chat" on disconnect
- [ ] **CP5.10** **TEST:** 2 browsers, messages appear in both

---

### Phase 6: Chat UI Polish
> Goal: Usable chat interface

- [ ] **CP6.1** Username input field before connecting
- [ ] **CP6.2** Server address input field (default: current host)
- [ ] **CP6.3** Connect/Disconnect button with state toggle
- [ ] **CP6.4** Message display area (scrollable div)
- [ ] **CP6.5** Style user messages vs system messages differently
- [ ] **CP6.6** Add timestamps to messages
- [ ] **CP6.7** Auto-scroll to newest message
- [ ] **CP6.8** Message input + Send button
- [ ] **CP6.9** Send on Enter key press
- [ ] **CP6.10** **TEST:** Full chat flow feels usable

---

### Phase 7: Cross-Platform Testing
> Goal: Works on Mac and Windows

- [ ] **CP7.1** Test server on macOS
- [ ] **CP7.2** Test server on Windows
- [ ] **CP7.3** Test client on Chrome
- [ ] **CP7.4** Test client on Firefox
- [ ] **CP7.5** Test with 5 simultaneous clients
- [ ] **CP7.6** Test Hebrew messages (UTF-8)
- [ ] **CP7.7** Fix any platform-specific issues (paths, line endings)
- [ ] **CP7.8** **TEST:** Full demo Mac→Windows or vice versa

---

### Phase 8: Wireshark Verification
> Goal: Traffic is analyzable in Wireshark

- [ ] **CP8.1** Capture traffic on port 8080
- [ ] **CP8.2** Verify TCP 3-way handshake (SYN, SYN-ACK, ACK)
- [ ] **CP8.3** Verify HTTP GET requests visible
- [ ] **CP8.4** Verify HTTP 101 Switching Protocols
- [ ] **CP8.5** Verify WebSocket frames visible
- [ ] **CP8.6** Verify TCP connection teardown (FIN, ACK)
- [ ] **CP8.7** Take screenshots for documentation
- [ ] **CP8.8** **TEST:** Can explain each packet in capture

---

### Phase 9: Documentation
> Goal: Hebrew documentation complete

- [ ] **CP9.1** Write `README.md` - project overview
- [ ] **CP9.2** Write `SETUP.md` - installation for Mac
- [ ] **CP9.3** Write `SETUP.md` - installation for Windows
- [ ] **CP9.4** Write `WIRESHARK.md` - capture filter setup
- [ ] **CP9.5** Write `WIRESHARK.md` - what to look for in capture
- [ ] **CP9.6** Add code comments explaining key sections
- [ ] **CP9.7** **FINAL:** Complete demo with documentation

---

## Risk & Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| WebSocket framing bugs | High | Follow RFC 6455 strictly, test each opcode |
| Thread safety issues | Medium | Always use Lock for shared state |
| Cross-platform path issues | Medium | Use `os.path.join()` or `pathlib` |
| UTF-8 encoding problems | Low | Encode/decode explicitly with `.encode('utf-8')` |
| Browser compatibility | Low | Use standard WebSocket API only |

---

## Dependencies

**Server (Python 3.8+):**
- `socket` (built-in)
- `threading` (built-in)
- `hashlib` (built-in)
- `base64` (built-in)
- `struct` (built-in, for frame parsing)

**No pip packages required!**

**Client:**
- Any modern browser (Chrome, Firefox, Safari, Edge)

**Testing:**
- Wireshark
- Two computers on same network (or localhost for dev)

---

## Next Steps

1. **Founder Approval** → Review and approve this blueprint
2. **Builder Begins** → Start with Phase 1 checkpoints
3. **Checker Reviews** → After each phase completion
4. **Wireshark Demo** → Final verification with capture

---

*Blueprint created by The Planner*
*Based on BrainStorm analysis and Library sources*
